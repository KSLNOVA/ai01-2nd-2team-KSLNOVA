<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Realtime Squat Coach Web</title>

  <script type="module">
    import {
      PoseLandmarker,
      FilesetResolver,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

    let video, canvas, ctx;
    let poseLandmarker;
    let drawingUtils;
    let frameIndex = 1;

    // ìµœì‹  ë¶„ì„ ë°ì´í„° ì €ì¥ìš©
    let latestAngles = null;

    // LLM í”¼ë“œë°±
    let lastFeedback = "";

    async function initCamera() {
      video = document.getElementById("video");
      canvas = document.getElementById("canvas");
      ctx = canvas.getContext("2d");

      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: 640, height: 480 }
      });

      video.srcObject = stream;
      await video.play();

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }

    // ê°ë„ ê³„ì‚°
    function calculateAngle(a, b, c) {
      const AB = [a.x - b.x, a.y - b.y];
      const CB = [c.x - b.x, c.y - b.y];
      const dot = AB[0] * CB[0] + AB[1] * CB[1];
      const magnitude = Math.hypot(...AB) * Math.hypot(...CB);
      return Math.acos(dot / magnitude) * (180 / Math.PI);
    }

    async function initPose() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );

      poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task",
        },
        runningMode: "VIDEO",
        numPoses: 1
      });

      drawingUtils = new DrawingUtils(ctx);
    }

    // ì„œë²„ë¡œ LLM ìš”ì²­ ë³´ë‚´ê¸°
    async function requestLLMFeedback(angles) {
      try {
        const res = await fetch("http://localhost:8000/feedback", {
          method: "POST",
          headers: {"Content-Type": "application/json"},
          body: JSON.stringify(angles)
        });

        const data = await res.json();
        return data.feedback;
      } catch (err) {
        console.error("LLM í˜¸ì¶œ ì˜¤ë¥˜", err);
        return null;
      }
    }

    // -------------------------------------
    // 1) ì‹¤ì‹œê°„ ì˜ìƒ ë¶„ì„ ë£¨í”„ (LLM ì—†ìŒ)
    // -------------------------------------
    async function predict() {
      if (!poseLandmarker) return;

      const results = poseLandmarker.detectForVideo(video, frameIndex++);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      if (results.landmarks && results.landmarks[0]) {
        const lm = results.landmarks[0];

        drawingUtils.drawLandmarks(lm);
        drawingUtils.drawConnectors(lm, PoseLandmarker.POSE_CONNECTIONS);

        const leftShoulder = lm[11];
        const rightShoulder = lm[12];
        const leftHip = lm[23];
        const rightHip = lm[24];
        const leftKnee = lm[25];
        const rightKnee = lm[26];
        const leftAnkle = lm[27];
        const rightAnkle = lm[28];

        const left_knee_angle = calculateAngle(leftHip, leftKnee, leftAnkle);
        const right_knee_angle = calculateAngle(rightHip, rightKnee, rightAnkle);
        const left_torso_angle = calculateAngle(leftShoulder, leftHip, leftKnee);
        const right_torso_angle = calculateAngle(rightShoulder, rightHip, rightKnee);

        document.getElementById("leftAngle").innerText = left_knee_angle.toFixed(1);
        document.getElementById("rightAngle").innerText = right_knee_angle.toFixed(1);
        document.getElementById("torsoAngle").innerText =
          ((left_torso_angle + right_torso_angle) / 2).toFixed(1);

        // â˜… LLM í˜¸ì¶œìš© ë°ì´í„° ì €ì¥ë§Œ í•œë‹¤ (í˜¸ì¶œ X)
        latestAngles = {
          left_knee: left_knee_angle,
          right_knee: right_knee_angle,
          left_torso: left_torso_angle,
          right_torso: right_torso_angle
        };
      }

      requestAnimationFrame(predict);
    }

    // ---------------------------------------
    // 2) LLM í˜¸ì¶œ ì „ìš© íƒ€ì´ë¨¸ (5ì´ˆ ê°„ê²©)
    // ---------------------------------------
      setInterval(async () => {
        if (!latestAngles) return;

        const feedback = await requestLLMFeedback(latestAngles);
        if (!feedback) return;

        // ì¤‘ë³µ í”¼ë“œë°± ë°©ì§€
        if (feedback !== lastFeedback) {
          lastFeedback = feedback;
          document.getElementById("feedbackText").innerText = feedback;

          // ğŸ”¥ ì •ìƒ ìì„¸ë¼ë©´ TTS ë§í•˜ì§€ ì•ŠìŒ
          const normalized = feedback.replace(/\s/g, '');

          const normalPatterns = [
            "ì •ìƒìì„¸ì…ë‹ˆë‹¤.",
            "ìì„¸ì¢‹ìŠµë‹ˆë‹¤.",
            "ì¢‹ì•„ìš”.",
            "ì¢‹ìŠµë‹ˆë‹¤.",
            "ë¬¸ì œì—†ìŠµë‹ˆë‹¤."
           ];
           const isNormal = normalPatterns.some(p => normalized.includes(p));

           if (!isNormal) {
             // ë¬¸ì œ ìˆì„ ë•Œë§Œ TTS ì‹¤í–‰
             const utter = new SpeechSynthesisUtterance(feedback);
             utter.lang = "ko-KR";
             speechSynthesis.speak(utter);
          }
        }
      }, 2500);

    async function start() {
      await initCamera();
      await initPose();
      predict();
    }

    window.onload = start;
  </script>

  <style>
    body { font-family: Arial; padding: 20px; }
    #canvas { border: 1px solid #ccc; }
  </style>
</head>
<body>

  <h2>ğŸ‹ï¸ ì‹¤ì‹œê°„ LLM ìŠ¤ì¿¼íŠ¸ ì½”ì¹˜</h2>

  <video id="video" playsinline style="display:none;"></video>
  <canvas id="canvas"></canvas>

  <h3>ğŸ“Š ì‹¤ì‹œê°„ ì¸¡ì •</h3>
  <p>ì™¼ìª½ ë¬´ë¦ ê°ë„: <span id="leftAngle">0</span>Â°</p>
  <p>ì˜¤ë¥¸ìª½ ë¬´ë¦ ê°ë„: <span id="rightAngle">0</span>Â°</p>
  <p>ìƒì²´ ê¸°ìš¸ê¸° í‰ê· : <span id="torsoAngle">0</span>Â°</p>

  <h3>ğŸ—£ ì‹¤ì‹œê°„ ì½”ì¹­</h3>
  <p id="feedbackText">-</p>

</body>
</html>
